# -*- coding: utf-8 -*-
"""1638106_SSN_Práctica1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qvv58MfW8rMNkHlZh5LGVaobkxvRgVu7
"""

#Primero Importamos ambos programas que haremos servir, tanto numpy como matplotlib.pyplot.
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
# Haremos varios ejercicios para probar el conocimiento de clase. Primero haremos ejercicios de fundamentos de las matemáticas para práctica de matrices.

"""**Ejercicio 1**. Decidid para que valores de los parámetros *a,b y c* las matrices siguientes són invertibles y, cuando sea posible calculad su inversa."""

#Primero definimos las variables con sp.Symbol a diferencia de np, no lo cuenta o como valor o como texto, lo tendrá en cuenta como una variable.
a = sp.Symbol('a')
b = sp.Symbol('b')
c = sp.Symbol('c')

#Definimos las matrices, esto se hace con el comando sp.Matrix y se coloca las variables a, b y c como si fuera texto.
A = sp.Matrix([[1, -1, 'a'], [-2, -5, 1], [-3, -7, 0]])
B = sp.Matrix([[2, 'b', 5], [-1, 0, 2], [1, 1, 1]])
C = sp.Matrix([['c', 0, 0, 0, 0],[1, 'c', 0, 0, 0],[0, 0, 'c', 0, 0],[0, 0, 1, 'c', 0],[0, 0, 0, 0, 'c']])

#Para ver los valores que no pueden invertirse son aquellos en los que el determinante da 0, por lo que calcularemos todos los determinantes, se realiza con el comando A.det()
det_A = A.det()
det_B = B.det()
det_C = C.det()


#Imprimimos los resultados, ya que no se muestran a menos que explicitamente lo digamos.
print(det_A)
print(det_B)
print(det_C)

#Ahora resolveremos lo que seria el determinante usando la fórmula sp.solve(fórmula a resolver, constante que se quiere encontrar el valor)
Valor_no_inv_de_A = sp.solve(det_A,a)
Valor_no_inv_de_B = sp.solve(det_B,b)
Valor_no_inv_de_C = sp.solve(det_C,c)

#Como siempre, ha hecho el resultado pero se lo guarda para el ordenador mismo, tenemos que hacer que lo enseñe con print.
print(Valor_no_inv_de_A)
print(Valor_no_inv_de_B)
print(Valor_no_inv_de_C)

#Por último hacemos la inversa con el comando Matrix.inv().
A_inv = A.inv()
B_inv = B.inv()
C_inv = C.inv()

#Mostramos el resulado con print
print(A_inv)
print(B_inv)
print(C_inv)

"""**Ejercicio 2** Calcula la probilidad de un electrón con la función Fermi-Dirac y haz la diferencia para 2 electrones con diferentes potenciales."""

#Primero llamamos una función que es la distribución de fermi dirac, esta le pondremos 3 argumentos o elementos en nuestro caso, ya que k_B es una constante que definiremos, con la ultima que devuelve es la que calcula la función de distribución de Fermi-Dirac con la forma y da el reusltado
def fermi_dirac(E, mu, T):
  """Calculo de la función de distribución de Dirac."""
  k_B = 8.617333262145e-5  # Boltzmann constant in eV/K
  return 1 / (np.exp((E - mu) / (k_B * T)) + 1)

#Como queremos para varias formas, en este caso haremos una forma general para 2 potenciales en eV y temperaturas en K, en mi caso colocaré valores de 0.5 aprox eV, si queremos mas se puede ampliar con tal de obtener mayores rangos, pero mi ordenador no es el mejor.
mu1 = float(input("Potencial del primer material (eV): "))
mu2 = float(input("Potencial del segundo material (eV): "))
T = float(input("Poner la Temperatura (K): "))

# Con esta fórmula vemos para crear el espacio, en este caso tenemos que np.linspace da una secuencia de numeros separados por la misma distancia, el término mu1-0.5 es el inicio y mu2+0.5 da el final. 500 son el número de puntos apra hacer la gráfica
E = np.linspace(mu1 - 0.5, mu2 + 0.5, 500) #En caso de querer, se puede tocar el rango para que se vea mas o menos.

#Se calcula la fórmula que hemos visto, en este caso se ha usado def para no definir E, mu y T como se ha hecho en el ejercicio previo con sp.
# The prob1 and prob2 calculations are moved here, after E is defined
prob1 = fermi_dirac(E, mu1, T)
prob2 = fermi_dirac(E, mu2, T)

# Probabilidad de diferencia de ambas probabilidades se hace el valor absoluto
diff_prob = np.abs(prob1 - prob2)

# Grafica
plt.figure(figsize=(10, 6)) #Tamaño de la grafica
plt.plot(E, prob1, label=f'Material 1 (μ = {mu1:.2f} eV)') #Probabilidad material 1(prob1) función energia, etiqueta tiene potencial químico electrico.
plt.plot(E, prob2, label=f'Material 2 (μ = {mu2:.2f} eV)') #Probabilidad material 2(prob1) función energia, etiqueta tiene potencial químico electrico.
plt.xlabel('Energia (eV)') #Nombre eje x
plt.ylabel('Probabilidad Fermi-Dirac') #Nombre eje y
plt.title(f'Distribución de Fermi-Dirac de dos materiales at T = {T:.2f} K')
plt.legend()
plt.grid(True)

plt.figure(figsize=(10, 6)) #Tamaño letra
plt.plot(E, diff_prob, label='Diferencia entre probabilidad', color='red') #Color de la linea
plt.xlabel('Energia (eV)') #Eje X nombre
plt.ylabel('Diferencia de probabilidades') #Eje y nombre
plt.title('Diferencia entre la probabilidad de Fermi-Dirac') #Título de todo
plt.legend() #Leyenda
plt.grid(True) #Cuadricula la gráfica

plt.show()

#Este ejercicio ayuda a enseñar que con la diferencia de potenciales si hay un nivel disponible entre estos materiales uno tiene estados ocupados mientras que el otro no, los electrones pueden moverse de uno a otro.

"""**Ejercicio Extra** Se ha realizado una modificación ligera usando una combinación, esto podria representar una combinación de ondas."""

def complex_function(x):
    a = 2.0  # Un Coeficiente seleccionado al azar
    b = 1.5  # Coeficiente 2
    f = np.exp(-a * x) * np.cos(2 * np.pi * x) + b * np.sin(3 * np.pi * x) * np.exp(-0.5 * x) #Ecuacion que haremos servir, mismo estilo que el ejercico previo
    return f

# Aqui se definen los diferentes valores de x
dx = 0.01 #Define el diferencial, se podria poner en input si se desea.
x_list = np.arange(0.0, 6.0, dx)

# Evaluar la función
y = complex_function(x_list)

# Esto es para la derivada numérica, se explica que hace cada paso.
dy = [] #Lista vacia 1
x_derivative = [] #Lista vacia 2
for i in range(len(x_list) - 1): #Se hace bucle de la lista que hemos hecho antes, desde 0 hasta x-1 para evitar problemas por error de indice fuera de rango,
    diffx = x_list[i+1] - x_list[i] #Cálculo entre la diferencia de consecutivos y se almacena en diffx, es el cambio en x
    diffy = y[i+1] - y[i] #Igual con y
    dy.append(diffy / diffx) #Esto se aplica para la derivada
    x_derivative.append(x_list[i])

# Graficar la función y su derivada, similar al ejercicio previo
plt.plot(x_list, y, 'r', label='Función Combinada')
plt.plot(x_derivative, dy, 'b', label='Derivada Función Combinada')
plt.xlabel('x')
plt.ylabel('Amplitud') #No se ha considerado ninguna unidad, podemos tener en cuenta nm que es lo más común en nuestro campo
plt.legend()
plt.title('Función Combinada y su Derivada')
plt.show()

